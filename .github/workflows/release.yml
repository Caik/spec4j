name: Release

on:
  # Automatic release on PR merge to main
  push:
    branches:
      - main
  # Manual trigger as fallback
  workflow_dispatch:
    inputs:
      version_increment:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  contents: write

jobs:
  # First job: Check if release should be skipped
  check-release:
    name: Check if release needed
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ” Check changed files
        id: check
        run: |
          # For manual triggers, always release
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - proceeding with release"
            exit 0
          fi

          # Get the merge commit's parents and find changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Define blacklist patterns (paths that don't trigger release)
          BLACKLIST_PATTERNS=(
            "^examples/"
            ".*Test\.kt$"
            ".*Tests\.kt$"
            ".*/test/.*"
            ".*\.md$"
            "^\.github/"
            "^docs/"
          )

          # Check if ALL changed files match blacklist
          SHOULD_RELEASE="false"
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            MATCHES_BLACKLIST="false"
            for pattern in "${BLACKLIST_PATTERNS[@]}"; do
              if echo "$file" | grep -qE "$pattern"; then
                MATCHES_BLACKLIST="true"
                break
              fi
            done
            if [ "$MATCHES_BLACKLIST" = "false" ]; then
              echo "File '$file' is not in blacklist - release needed"
              SHOULD_RELEASE="true"
              break
            fi
          done <<< "$CHANGED_FILES"

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          if [ "$SHOULD_RELEASE" = "false" ]; then
            echo "All changed files are in blacklist - skipping release"
          fi

  release:
    name: Release
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.should_release == 'true'

    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for axion-release and changelog

      - name: â˜• Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: temurin

      - name: ðŸ“¦ Setup Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: ðŸ”¨ Build & Test
        run: ./gradlew build

      - name: ðŸ” Check if HEAD is already tagged
        id: check_tag
        run: |
          # Check if current HEAD has a tag
          CURRENT_TAG=$(git tag --points-at HEAD | grep -E "^v[0-9]" | head -1 || echo "")
          
          if [ -n "$CURRENT_TAG" ]; then
            echo "has_tag=true" >> $GITHUB_OUTPUT
            echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
            echo "âš ï¸ HEAD is already tagged as $CURRENT_TAG"
          else
            echo "has_tag=false" >> $GITHUB_OUTPUT
            echo "âœ“ HEAD has no release tag"
          fi

      - name: ðŸ›‘ Abort if already released (automatic only)
        if: steps.check_tag.outputs.has_tag == 'true' && github.event_name != 'workflow_dispatch'
        run: |
          echo "::error::HEAD is already tagged as ${{ steps.check_tag.outputs.current_tag }}. No new commits to release."
          echo "Push new commits or use manual trigger to force a release."
          exit 1

      - name: ðŸ·ï¸ Determine version increment from commits
        id: incrementer
        run: |
          # For manual triggers, use the input
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            case "${{ github.event.inputs.version_increment }}" in
              major) echo "incrementer=incrementMajor" >> $GITHUB_OUTPUT ;;
              minor) echo "incrementer=incrementMinor" >> $GITHUB_OUTPUT ;;
              *)     echo "incrementer=incrementPatch" >> $GITHUB_OUTPUT ;;
            esac
            exit 0
          fi

          # For automatic releases, analyze commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$LAST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%s" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%s" ${LAST_TAG}..HEAD)
          fi

          echo "Analyzing commits since $LAST_TAG:"
          echo "$COMMITS"

          # Check for breaking changes (major)
          if echo "$COMMITS" | grep -qE "^(feat|fix|refactor|perf)(\(.+\))?!:|BREAKING CHANGE:"; then
            echo "incrementer=incrementMajor" >> $GITHUB_OUTPUT
            echo "Detected: MAJOR (breaking change)"
            exit 0
          fi

          # Check for features (minor)
          if echo "$COMMITS" | grep -qE "^feat(\(.+\))?:"; then
            echo "incrementer=incrementMinor" >> $GITHUB_OUTPUT
            echo "Detected: MINOR (new feature)"
            exit 0
          fi

          # Check for fixes/perf (patch)
          if echo "$COMMITS" | grep -qE "^(fix|perf)(\(.+\))?:"; then
            echo "incrementer=incrementPatch" >> $GITHUB_OUTPUT
            echo "Detected: PATCH (fix/perf)"
            exit 0
          fi

          # Default to patch for any other conventional commits
          echo "incrementer=incrementPatch" >> $GITHUB_OUTPUT
          echo "Detected: PATCH (default)"

      - name: ðŸ“‹ Get current version
        id: current_version
        run: |
          VERSION=$(./gradlew currentVersion -q | grep "Project version:" | awk '{print $3}')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: ðŸ§® Calculate next version (if HEAD already tagged)
        id: next_version
        if: steps.check_tag.outputs.has_tag == 'true'
        run: |
          CURRENT="${{ steps.current_version.outputs.version }}"
          INCREMENTER="${{ steps.incrementer.outputs.incrementer }}"

          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"

          # Calculate next version based on incrementer
          case "$INCREMENTER" in
            incrementMajor)
              NEXT="$((MAJOR + 1)).0.0"
              ;;
            incrementMinor)
              NEXT="${MAJOR}.$((MINOR + 1)).0"
              ;;
            incrementPatch)
              NEXT="${MAJOR}.${MINOR}.$((PATCH + 1))"
              ;;
          esac

          echo "next=$NEXT" >> $GITHUB_OUTPUT
          echo "Calculated next version: $NEXT"

      - name: ðŸš€ Create Release Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # If HEAD is already tagged, force the calculated version
          if [ "${{ steps.check_tag.outputs.has_tag }}" = "true" ]; then
            echo "Forcing version ${{ steps.next_version.outputs.next }}"
            ./gradlew release -Prelease.forceVersion=${{ steps.next_version.outputs.next }}
          else
            ./gradlew release -Prelease.versionIncrementer=${{ steps.incrementer.outputs.incrementer }}
          fi

      - name: ðŸ“‹ Get new version
        id: version
        run: |
          VERSION=$(./gradlew currentVersion -q | grep "Project version:" | awk '{print $3}')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "New version: $VERSION"

      - name: ðŸ”¨ Rebuild with release version
        run: ./gradlew clean :lib:build

      - name: ðŸ“¤ Publish to Maven Central
        run: ./gradlew :lib:publishToMavenCentral
        env:
          ORG_GRADLE_PROJECT_mavenCentralUsername: ${{ secrets.ORG_GRADLE_PROJECT_mavenCentralUsername }}
          ORG_GRADLE_PROJECT_mavenCentralPassword: ${{ secrets.ORG_GRADLE_PROJECT_mavenCentralPassword }}
          ORG_GRADLE_PROJECT_signingInMemoryKey: ${{ secrets.ORG_GRADLE_PROJECT_signingInMemoryKey }}
          ORG_GRADLE_PROJECT_signingInMemoryKeyPassword: ${{ secrets.ORG_GRADLE_PROJECT_signingInMemoryKeyPassword }}

      - name: ðŸ“ Generate changelog
        uses: orhun/git-cliff-action@v4
        id: changelog
        with:
          config: cliff.toml
          args: --latest --strip header
        env:
          OUTPUT: CHANGELOG.md
          GITHUB_REPO: ${{ github.repository }}

      - name: ðŸ” Generate checksums
        run: |
          cd lib/build/libs
          JAR_FILE="spec4j-core-${{ steps.version.outputs.version }}.jar"
          echo "SHA-256:" > checksums.txt
          sha256sum "$JAR_FILE" >> checksums.txt
          echo "" >> checksums.txt
          echo "SHA-512:" >> checksums.txt
          sha512sum "$JAR_FILE" >> checksums.txt
          echo "Generated checksums:"
          cat checksums.txt

      - name: ðŸ“¦ Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: v${{ steps.version.outputs.version }}
          body: ${{ steps.changelog.outputs.content }}
          draft: false
          prerelease: false
          files: |
            lib/build/libs/checksums.txt
            lib/build/libs/spec4j-core-${{ steps.version.outputs.version }}.jar
